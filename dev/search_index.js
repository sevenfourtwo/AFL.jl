var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"AFL.Result\nAFL.Target\nAFL.CoverageMap\nAFL.InvCoverageMap\ninit_target\nrun_target\nclassify_coverage\nclassify_coverage!\ncoverage_stats\nhas_new_coverage\nmark_covered!","category":"page"},{"location":"api/#AFL.Result","page":"API","title":"AFL.Result","text":"Result\n\nEnum representing the return state of the running the target with an input.\n\n\n\n\n\n","category":"type"},{"location":"api/#AFL.Target","page":"API","title":"AFL.Target","text":"Target\n\nRepresents a running AFL forkserver and a shared memory segment for the branch bitmap. Create one with  init_target and close the handle with close.\n\n\n\n\n\n","category":"type"},{"location":"api/#AFL.CoverageMap","page":"API","title":"AFL.CoverageMap","text":"CoverageMap\n\nAn array of bytes used to describe the coverage an input generated. Each byte represents  a specific edge between in the code that can be covered, each bit represents a classification  of counts this edge was taken. \n\n\n\n\n\n","category":"type"},{"location":"api/#AFL.InvCoverageMap","page":"API","title":"AFL.InvCoverageMap","text":"InvCoverageMap\n\nSee CoverageMap. This is an inverted version, which can be faster in some cases. Often used  to describe edges and counts not covered yet.\n\n\n\n\n\n","category":"type"},{"location":"api/#AFL.init_target","page":"API","title":"AFL.init_target","text":"init_target(target_path::String; qemu=false, memlimit=200)\n\nStart a forkserver for the given target.\n\n\n\n\n\n","category":"function"},{"location":"api/#AFL.run_target","page":"API","title":"AFL.run_target","text":"run_target(target::Target, input::Vector{UInt8}; timeout=1)\n\nRun the target with the specified input. Times out after timeout seconds. Return value is a Result enum.\n\n\n\n\n\n","category":"function"},{"location":"api/#AFL.classify_coverage","page":"API","title":"AFL.classify_coverage","text":"classify_coverage(target::Target)\n\nConvert the trace bits in the shared memory segment of the target to a classified coverage map.\n\n\n\n\n\n","category":"function"},{"location":"api/#AFL.classify_coverage!","page":"API","title":"AFL.classify_coverage!","text":"classify_coverage!(dst::CoverageMap, target::Target)\n\nIn place version of classify_coverage.\n\n\n\n\n\n","category":"function"},{"location":"api/#AFL.coverage_stats","page":"API","title":"AFL.coverage_stats","text":"edges_covered, classes_covered = coverage_stats(map::CoverageMap)\nedges_covered, classes_covered = coverage_stats(map::InvCoverageMap)\n\nCalculate the ratio of edges and classes covered in the give coverage map. The maximum possible  coverage (1024 * 64 edges covered) is represented as 1.0.\n\n\n\n\n\n","category":"function"},{"location":"api/#AFL.has_new_coverage","page":"API","title":"AFL.has_new_coverage","text":"has_new_coverage(dst::InvCoverageMap, src::CoverageMap)\n\nCompares dst with src and returns true when src covers edges or classes not yet  marked as covered in src, otherwise returns false.\n\n\n\n\n\n","category":"function"},{"location":"api/#AFL.mark_covered!","page":"API","title":"AFL.mark_covered!","text":"mark_covered!(dst::InvCoverageMap, src::CoverageMap)\n\nMarks the edges and classes covered by src as covered in dst.\n\n\n\n\n\n","category":"function"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package provides an interface to use the binary instrumentation logic from the American Fuzzy Lop (AFL) fuzzer in Julia. No fuzzing algorithm is implemented in this package, it serves merely as a starting point to do so. Technical details of te instrumentation logic from AFL can be found here. The code in this packages borrows heavily from the afl-fuzz program. Both source code based fuzzing and QEMU mode are supported.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"At this point it implements only the minimal code to get instrumentation working. To handle some of the forkserver logic a simple C shim is build as a dependency (see deps/afl-shim.c).","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package is not available in the in Julia registry yet. For now, it can be installed with the following command in the REPL:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"] add https://github.com/sevenfourtwo/AFL.jl https://github.com/sevenfourtwo/AFL_jll.jl ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"GCC is required to compile the loading shim.","category":"page"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"This is a description of several implementation details. See also the techincal_details.txt file in the AFL repository for more information.","category":"page"},{"location":"internals/#Shared-Memory-Segment","page":"Internals","title":"Shared Memory Segment","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"The shared memory segment is used as an IPC mechanism to retrieve information about the coverage from the target process. The memory segment is used as a vector of 65536 (1024*64) UInt8's. The id of and a pointer to the memory segment are part of the Target struct.","category":"page"},{"location":"internals/#Coverage","page":"Internals","title":"Coverage","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Coverage is monitored inside the target program, the code responsible for this is compiled into the target by the afl-gcc and afl-as programs. Every time the program counter reaches a new basis block a byte is incremented in the shared memory segment, the index of of the byte increment is depending on the basic block to be executed and the previous executed block.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"The coverage data can be read in julia and converted to a CoverageMap. In this coverage map the counts are convered to bytes with zero or one high bits, representing a class of counts. The byte values corresponding to counts can be viewed in the following table.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Byte Count\n0x00 0\n0x01 1\n0x02 2\n0x04 3\n0x08 4-7\n0x10 8-15\n0x20 16-31\n0x40 32-127\n0x80 128-255","category":"page"},{"location":"internals/#Shim","page":"Internals","title":"Shim","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"The shim (see deps/afl-shim.c) is used a as a stub to start the actual program under test. It's tasks are:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Set the resource limits for the program\nDuplicate stdin to fd 198 and stdout to 199, these fds will be used by the AFL forkserver to communicate with AFL.jl\nThe input file will be openend and it's fd duplicated to stdin\nStdout and stderr will be redirected to /dev/null\nFinally an execv call will be made to start the real target program","category":"page"},{"location":"internals/#Forkserver","page":"Internals","title":"Forkserver","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Now that the real target is running it will first execute the AFL forkserver (not part of AFL.jl), this code will do the following:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Check if fd 198 and 199 are open\nAttach the shared memory segment (reading it's id from environment variable __AFLSHMID)\nSend a four byte hello message over the status socket (fd 199)\nWait for a four byte start message on the control socket (fd 198)\nFork (the chilld process will hand over execution to the actual program under test)\nSend the pid of the child over the status socket\nWait until the child terminates and send the exitcode over the status socket, continue with step 4","category":"page"},{"location":"example/#Example","page":"Example","title":"Example","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"To use this package to instrument a program it needs te be compiled with the afl-gcc or afl-clang program which is part of AFL and can be installed on most Linux systems from the package manager (afl++ on Ubuntu, american-fuzzy-lop on Fedora). The binary AFL_jll package does also ship a precompiled afl-gcc, its path can be retrieved in Julia as AFL_jll.afl_gcc_exe_path.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"note: Note\nAFL_jll is based on AFL++, but AFL.jl can handle both programs instrumented with the original AFL tools as well as the AFL++ tools.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Load the required packages (AFL_jll is a binary dependecy of AFL.jl, here it is explicitly required to access to test program):","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"using AFL, AFL_jll","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"For this example the AFL test program (source) is used, a compiled version is shipped with the AFL_jll package. The target can be started from the Julia REPL:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"target = init_target(AFL_jll.afl_test_instr_exe_path);","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"note: Note\nThe test program does only work correctly on i686 and x86_64 systems.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"We have created a forkserver instance for our target. The forkserver is actually the target binary but it is still running the AFL trampoline code and waiting for a command. When this command is given the target will fork itself and the child will become the actual target. Communication with the forkserver and the actual target is implemented in this package.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Running the target with only zero bytes as input results in a clean execution as can be seen in the following example:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"run_target(target, b\"0\")","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Using the instrumentation tools we can see that several branches were covered with this input (the classify_coverage function convert the trace bit from the execution to a coverage map and the coverage_stats function returns the ratio of edges and classes covered by this input). The meaning of the edge classes can be found in the coverage section.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"coverage = classify_coverage(target);\ncoverage_stats(coverage)\n[i => class for (i, class) in enumerate(coverage.edges) if class > 0]","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"warning: Warning\nThe edge numbers are randomly generated every time the target program is compilated. Make sure you only compare those values in runs of the exact same target program.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"By changing to input we can see the code takes some more branches, covering more code.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"run_target(target, b\"12345678\")\ncoverage = classify_coverage(target);\ncoverage_stats(coverage)\n[i => class for (i, class) in enumerate(coverage.edges) if class > 0]","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"When finished close the connection with the forkserver with:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"close(target)","category":"page"}]
}
